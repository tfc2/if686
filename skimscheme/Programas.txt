“Além do interpretador, a equipe deve construir pelo menos dez
programas corretos e que testem todas as funcionalidades implementadas
pelo interpretador. Esses testes devem incluir situações onde várias
funcionalidades são combinadas. Os programas desenvolvidos devem estar
disponíveis no momento da apresentação do projeto.
Pelo menos um desses programas deve implementar o algoritmo Quicksort
recursivamente e pelo menos dois devem usar clausuras léxicas”

1. Fibonacci

1.1 Estrutura:

(begin
    (comment funcao fibonacci)
    (define fib
        (lambda (n)
            (if ( eqv? n 0) 0
            (if ( eqv? n 1) 1
            (+ (fib (- n 1)) (fib (- n 2)))))))
    (fib 4)
)

1.2 Teste:

runhaskell SSInterpreter.hs "(begin (comment funcao fibonacci) (define fib (lambda (n) (if (eqv? n 0) 0 (if (eqv? n 1) 1 (+ (fib (- n 1)) (fib (- n 2))))))) (fib 4) )"

1.3 Saída:

3
[("fib",lambda ((n) (if (eqv? n 0) 0 (if (eqv? n 1) 1 (+ (fib (- n 1)) (fib (- n 2)))))))]



2. Divisível por 6

2.1 Estrutura:

(begin
    (let ((a 1))
        (define divisivel2
            (make-closure
                (lambda (x)
                    (begin (set! a (mod x 2)))
                )
            )
        )
    )
    (let ((b 1))
        (define divisivel3
            (make-closure
                (lambda (y)
                    (begin (set! b (mod y 3)))
                )
            )
        )
    )
    (define divisivel6
        (lambda (z)
            (if ( eqv? (divisivel2 z) 0 )
                (if ( eqv? (divisivel3 z) 0 ) #t #f )
            #f)
         )
    )
    (comment caso teste)
    (divisivel6 24)
)

2.2 Teste:

runhaskell SSInterpreter.hs "(begin (let ((a 1)) (define divisivel2 (make-closure (lambda (x) (begin (set! a (mod x 2))) ) ) ) ) (let ((b 1)) (define divisivel3 (make-closure (lambda (y) (begin (set! b (mod y 3))) ) ) ) ) (define divisivel6 (lambda (z) (if ( eqv? (divisivel2 z) 0 ) (if ( eqv? (divisivel3 z) 0 ) #t #f ) #f) ) ) (comment caso teste) (divisivel6 24) )"

2.3 Saída:

#t
[("a",0),("b",0),("divisivel2",lambda ((x) (begin (set! a (mod x 2)))) environme
nt: fromList [("*",<native procedure>),("+",<native procedure>),("-",<native pro
cedure>),("/",<native procedure>),("a",1),("boolean?",<native procedure>),("car"
,<native procedure>),("cdr",<native procedure>),("cons",<native procedure>),("eq
v?",<native procedure>),("list?",<native procedure>),("lt?",<native procedure>),
("mod",<native procedure>),("number?",<native procedure>)]),("divisivel3",lambda
 ((y) (begin (set! b (mod y 3)))) environment: fromList [("*",<native procedure>
),("+",<native procedure>),("-",<native procedure>),("/",<native procedure>),("b
",1),("boolean?",<native procedure>),("car",<native procedure>),("cdr",<native p
rocedure>),("cons",<native procedure>),("eqv?",<native procedure>),("list?",<nat
ive procedure>),("lt?",<native procedure>),("mod",<native procedure>),("number?"
,<native procedure>)]),("divisivel6",lambda ((z) (if (eqv? (divisivel2 z) 0) (if
 (eqv? (divisivel3 z) 0) #t #f) #f)))]
 
 Obs.: substituindo 24 por 23, por exemplo, a saída retorna #f.



3. Inclui número maior que 5 em uma lista

3.1 Estrutura:

(begin
    (define maior5
        (lambda (n)
            (if (lt? 5 n) (cons n '(7 8 9 10)) '(7 8 9 10) )
        )
    )
    (maior5 6)
)

3.2 Teste:

runhaskell SSInterpreter.hs "(begin (define maior5 (lambda (n) (if (lt? 5 n) (cons n '(7 8 9 10)) '(7 8 9 10) ) ) ) (maior5 6) )"

3.3 Saída:
(6 7 8 9 10)
[("maior5",lambda ((n) (if (lt? 5 n) (cons n (quote (7 8 9 10))) (quote (7 8 9 10)))))]

Obs.: substituindo 6 por 3, por exemplo, a saída retorna a lista antiga sem incluir o número 3.

4. Divide por dois

4.1 Estrutura:

(begin
    (define x 10)
    (comment exemplo com variavel local e recursao)
    (define f
        (lambda (x)
            (/ x 2)
        )
    )
    (comment a funcao abaixo deve retornar 4 e nao 5)
    (f 8)
)

4.2 Teste:

runhaskell SSInterpreter.hs "(begin (define x 10) (comment exemplo com variavel local e recursao) (define f (lambda (x) (/ x 2))) (comment a funcao abaixo deve retornar 4 e nao 5) (f 8))"

4.3 Saída:

C:\Users\tfc2\Downloads\if686-master\skimscheme>runhaskell SSInterpreter.hs "(be
gin (define x 10) (comment exemplo com variavel local e recursao) (define f (lam
bda (x) (/ x 2))) (comment a funcao abaixo deve retornar 4 e nao 5) (f 8))"
4
[("f",lambda ((x) (/ x 2))),("x",10)]
